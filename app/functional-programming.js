import React, { Component } from "react";
import BlogPage from './blog-page.js';
import SyntaxHighlighter from 'react-syntax-highlighter';
import { darcula, docco } from 'react-syntax-highlighter/styles/hljs';
  


const functionalProgramming = {

    title: 'Functional Programming',
contents: '',    
text: [<div>
	   <p>In this section we will cover one of the greatest books of all time on funcational programming Structure and Interpretation of Computer Programs (Gerald Jay Sussman and Hal Abelson). Please give us a chance to get onto this! </p>

	   <h2>Building Abstractions with Procedures</h2>
	   <h3>Elements of Programming</h3>
	   <p>To build complex solutions in computers you need a programming language SICP focuses on using Scheme and we will use Clojure due to similarities. Clojure provides simple concepts that can be combined to build more complex solutions it does this by three main points: primitive expressions, means of combination and means of abstraction. A key point is made here we deal with two kinds of elements procedures and data and these are clearly separated at this point and are for functional progreamming but later on the book SICP says they become more entwined due to Object Oriented Programming. The first section of the book covers the basic of the language that we will skip here, but it does start to explain how to evaluate the code in a basic form of the substitution model, the operations values are substituted by the role and you can build up the end result using this method. Procdures should be black box operations hence the parameters passed in are local values to the procedure, in Clojure let can be used to define further local values to a procedure and you can use the block structure to structure these scopes and define sub procedures within procedures.</p>

<h3>Procedures and the Processes they Generate</h3>
																								<h4>Linear Recursion and Iteration</h4>																		<p>As programmers we need to be able to visualise the processes generated by the procedures that we write to ensure they work correctly and efficiently. This section discusses the shape of the process formed by procedures. The section uses factorial calculation to describe a linear recursive solution will expand out the calls of the function chaining them and then contracting as the functions are actually called. Alternatively a process that is iterative does not grow and contract but does keep state that is mutated but this enables the program to pick a certain part of the process and continue from that point. Remember we are talking about recursive processes here not recursive procedures.</p>																																			<SyntaxHighlighter language='clojure' style={darcula} showLineNumbers={true} wrapLines={true}>{`(defn factorial
  [n]
  (if (= n 1 )
    1
    (* n (factorial (- n 1)))))`}</SyntaxHighlighter>
																																																																																														<SyntaxHighlighter language='clojure' style={darcula} showLineNumbers={true} wrapLines={true}>{`(defn fact-iter
 [product counter max-count]
  (if (> counter max-count)
    product
    (fact-iter (* counter product)
               (inc counter)
               max-count)))

(defn factorial-linear
  [n]
  (fact-iter 1 1 n))`}</SyntaxHighlighter>

																																																																																																																								 <h4>Tree Recursion</h4>	<p>Another common patter of computation is tree recursion. The book uses fibonacci sequence to show this defined as each number is the sum of the previous two. The algorithm that is very simple is used here. </p>

<SyntaxHighlighter language='clojure' style={darcula} showLineNumbers={true} wrapLines={true}>{`(defn fibinacci
  [n]
  (cond (= n 0) 0
        (= n 1) 1
        :else (+ (fibinacci (dec n))
                 (fibinacci (- n 2)))))`}</SyntaxHighlighter>
																																																																																																																								 <p>This solution can be pictured as a recursive tree where to compute (fib 5) we have to compute (fib 3) and (fib 4) and for (fib 4) we compute (fib 3) and (fib 2) and for (fib 3) we compuete (fib 2) and (fib 1). Now we can see the duplication!</p>

																																																																																																																								 <h3>Formulating Abstractions with Higher Order Procedures</h3>
																																																																																																																								 <p>We have seen that procedures can accept numeric parameters but Higher Order Procedures can accept accept other procedures as arguments or return these procedures. This ability allows us to reduce duplicated code immensely which is a great thing the book covers an example of summing integers and cubes. Mathematicians discovered the sum pattern many years ago and formed the Sigma notation to represent it. Rather than defining new functions each time you can use lambdas that are functions without a name (anonymous function). The ability to pass in procedures not only reduces duplication but can make procedures more flexible and clearer to read.</p>

																																																																																																																								 
																																																																																																																								 <h2>Building Abstractions with Data</h2>
																																																																																																																								 <h3>Introduction to Data Abstraction</h3>
		<p>Previously we discussed building abstractions with Compound Procedures now we are going to investigate the benefits of being able to combine data objects to build compound data. This ability enables us to deal with data at a higher conceptual level than that of primitive data. The isolation of how the system deals with how data is represented and how the system processes data is called data abstraction.</p>																																			<p>Abstraction barriers are barriers that isolate the use of data abstractions from the barriers that implement them.</p>																																																																																			 <h3>Hierarchical Data and the Closure Property</h3>
																											<p></p>																																																																																													 <h3>Symbolic Data</h3>
			<p></p>																																																																																																																					 <h3>Multiple Representation for Abstract Data</h3>
			<p></p>																																																																																																																					 <h3>Systems with Generic Operations</h3>
<p></p>
</div>]
};




const FunctionalProgrammingPage = (props) => {
    return (
            <BlogPage
        title={functionalProgramming.title}
        contents={functionalProgramming.contents}
        text={functionalProgramming.text}
       /> 
    );
}
    

export default FunctionalProgrammingPage;
